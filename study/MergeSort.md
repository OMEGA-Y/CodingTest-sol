# MergeSort(병합정렬)
**nlogn** 시간으로 리스트를 정렬할 수 있는 방법이다. <br>
이해하기 정말 힘들었다.

병합정렬은 기존 리스트를 절반씩 분할해 **리스트의 원소 하나가 리스트가 될 때까지**(ex. [3]) 쪼갠다. <br>
쪼갠 리스트를 두 개씩 정렬된 상태로 합쳐 **최종적으로 정렬된 리스트 하나**를 만들어낸다. <br>

일반적으로 분할했을 때 왼쪽 리스트의 인덱스는 i로, 오른쪽 리스트의 인덱스는 j로 나타낸다. <br>
왼쪽 리스트와 오른쪽 리스트를 병합해 만들 새로운 정렬 리스트의 인덱스는 k로 나타낸다.

왼쪽과 오른쪽 리스트 두 개에서 원소를 하나씩 꺼내 새로운 배열에 정렬되도록 넣어줄 것이다.
**오른쪽 리스트에서 원소를 꺼내 넣어주면** 왼쪽 리스트에 남아있는 수(left_num)보다 작다는 것이기 때문에,
left_num(새로운 리스트에 들어가지 못한 수)들은 방금 오른쪽에서 꺼낸 원소보다 뒤로 가야 한다.
따라서 **cnt에 left_num만큼 더해준다.**

왼쪽 리스트에서 원소를 꺼내 새로운 리스트에 넣어준다면 cnt에 변화가 없다.
다만 왼쪽 리스트에 몇 개의 원소가 남았는지 알아야 하기 때문에 이 부분은 변수를 두어 따로 체크한다.

### MergeSort 주의사항
- MergeSort에서 swap의 최대 횟수는 O(N^2)이다.
- 마지막에 원본 배열에 새롭게 정렬한 배열을 복사해서 넣어줘야 한다. 왜냐하면 merge 함수에서 바라보는 배열은 원본 배열이기 때문이다.
- 또는 복사 대신에 정렬한 배열 자체를 return 하는 방식을 택한다. 시간초과가 날 수 있기 때문이다.